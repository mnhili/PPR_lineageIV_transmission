---
title: 'Modèle de probabilité de transmission : distance 30 cm'
author: "Manal NHILI"
output:
  html_document:
    theme: paper
    fig_caption: yes
    fig_height: 4
    fig_width: 6
    toc: yes
    number_sections: yes
    always_allow_html: true
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE, 
  warning = FALSE
)
```

# Importing libraires

```{r}
# Reporting
library(knitr) # R code chunking in documents
library(rmarkdown) # Dynamic report generation

# Visualization 
library(ggplot2) # Graphing/visualization
library(DT) # Interactive HTML tables
library(gt) # Nicely formatted plain tables
library(httpgd) # HTTP graphics device

# Bayesian Modeling & MCMC
library(nimble) # Building MCMC models  
library(coda) # MCMC diagnostics
library(bayesplot) # MCMC diagnostics
library(postpack) # Post-processing MCMC draws
library(loo) # Leave-one-out cross validation
library(mcmcplots) # MCMC traceplots  

# Model Evaluation
library(Metrics) # Model evaluation metrics
library(ROCR) # Model performance visualization
library(caret) # Machine learning model evaluation

# Data Wrangling
library(tidyr) # Data tidying
library(dplyr) # Data manipulation
library(readxl) # Excel data I/O
```

# Importing data

```{r}
sero <- read_excel("data_seg_30cm.xlsx")

datatable(sero)

```

```{r}
ggplot(sero, aes(x = factor(infected))) +
  geom_bar(aes(fill = factor(infected)), position = "dodge") +
  labs(title = "Distribution of observational data : infectious status", x = "Value", y = "Count") +
  scale_fill_manual(values = c("0" = "blue", "1" = "red")) +
  theme_minimal()

```

# Model

## Contact distances:

We segmented the distance between study animals into three intervals: less than 30cm, less than 1m, and less than 2m. For each susceptible animal, we calculated the cumulative duration of contact ($t$) at each distance threshold with the seeds across the entire experimental infection phase. Contact duration was defined as the total time a susceptible animal spent less than 30cm, 1m, and 2m from an infected animal.

## Infection probability:

For each contact distance threshold, we estimated the probability $P_{ind}$ that a susceptible animal would become infected after a exposure duration $t$ at that proximity to the seed during the exposure phases. This allows estimating distance-based transmission probabilities based on $t$, the total contact time below 30cm, 1m or 2m with the seed over the course of the experiment. We fit infection probability model of the form:

$$P_{ind}(i) = 1-(1-p)^{t(i)} $$

Where :

-   $P_{ind}$ : the probability of getting infected by the seed
-   $p$ : probability of not getting infected
-   $t$ : total time spent under a defined distance during each experiment

## Statistical analysis:

We estimated the distance-based infection probability models using Bayesian methods implemented via Markov chain Monte Carlo (MCMC) in the `NIMBLE` package for R. Bayesian analysis allows directly estimating the probability parameters from the data while accounting for uncertainty through prior distributions. We specified weakly informative uniform prior distribution on the parameter $p$ and performed posterior inference using MCMC.

-   Uniform prior on $p$: $p \sim \mathbb{U}(0.0005, 0.01)$

-   Bernoulli likelihood: $y(i) \sim \mathbb{B}(p)$ , $y$ represents the column of infectious status of animals

The MCMC routine was run for 10,000 iterations across 10 chains with a thin rate of 2 using the following parameters: an initial burn-in of 10 samples per chain.

```{r, eval=FALSE}
code <- nimbleCode({
  # Priors
  p ~ dunif(0.0005, 0.01)
  # Boucle sur les observations
  for (i in 1:nrow(sero)) {
    p_ind[i] <- 1-(1-p)^t[i]
    y[i] ~ dbern(p_ind[i])}
})
```

```{r eval=FALSE}
ppr_mcmc <- nimbleMCMC(code = code,
                      data = data,
                      inits = inits,
                      thin = 2,
                      niter = 10000,
                      nburnin = 10, 
                      nchains = 10,
                      monitors = list("p", "p_ind"),
                      setSeed = 123,
                      progressBar = TRUE,
                      samples = TRUE,
                      summary = TRUE,
                      WAIC = TRUE)

```

```{r}
load("p_samples_30cm.RData")
```

We used different values for the parameter $p$ to initialize the MCMC chains.

```{r}
#datatable(theta_inits)

gt(theta_inits) %>% 
  tab_header(title = "initial values for MCMC chains")

```

```{r include=FALSE}
codaSamples <- post_convert(ppr_mcmc$samples)
p <- codaSamples[, "p"]
```

# Visualization:

We plot the density of the posterior and the trace plot of the chains.

```{r}
plot(p, type = "l")

```

# Assessing model fit quality using WAIC

```{r}
waic <- ppr_mcmc$WAIC
waic
```

# Summary Statistics

```{r}
summary(p)
```

```{r}
loo_result <- loo(as.matrix(p))
print(loo_result)

```

```{r}
loo_result$diagnostics
```

# Convergence Diagnostics

We used both gelman and geweke diagnostics to assess the convergence of MCMC chains, the PSRF is equal to 1.

## Gelman-Rubin diagnostic

The Potential Scale Reduction Factor (PSRF), also known as the **Gelman-Rubin diagnostic** $(\hat{R})$, is a widely used metric for assessing the convergence of Markov Chain Monte Carlo (MCMC) chains in Bayesian analysis. A PSRF equal to 1 is indicative of well-converged chains. The diagnostic compares the variability within each chain to the variability between chains. A value of 1 suggests that the chains have reached a common distribution and have effectively explored the parameter space. In our analysis, the PSRF being equal to 1 provides confidence in the convergence of the MCMC chains, indicating that the chains have reached a stable and consistent estimate of the target distribution.

```{r}
gelman.diag(p)
```

```{r}
gelman.plot(p)
```

## Geweke's convergence diagnostic

The **Geweke's convergence diagnostic** was applied to assess the convergence of multiple MCMC chains. The diagnostic involves dividing each chain into two windows (typically the first 10% and the last 50% of iterations) and comparing the means of these segments using a z-score. A small z-score and comparable fractions in the two windows indicate convergence.

```{r}
geweke.diag(p)
```

```{r}
geweke.plot(p)
```

# Plot autocorrelation plots for all chains

Autocorrelation plots were generated to assess the correlation between successive observations in each Markov Chain Monte Carlo (MCMC) chain. The plots below illustrate the autocorrelation function (ACF) for the parameter $p$ in each chain.

```{r}
autocorr.plot(p)
```

# Effective sample size

The **effective sample size (ESS)** is a metric used in the context of Markov Chain Monte Carlo (MCMC) sampling to quantify the amount of information or independence captured by the samples. It provides an estimate of how many independent samples in the Markov chain are equivalent to the autocorrelated samples obtained.

$$
ESS = \frac{n}{1 + 2\sum_{t=1}^{T} \rho_t}
$$

In this formula:

-   $ESS$ is the effective sample size.

-   $n$ is the total number of samples.

-   $ρ_t$​ is the autocorrelation at lag $t$.

-   $T$ is the maximum lag considered in the autocorrelation calculation.

An ESS of 2832.586 suggests good mixing and provides a reasonable estimate of the effective information content in our MCMC samples for the variable **`p`**.

```{r}
cat(effectiveSize(p)) 

```

# Posterior predictive check

```{r}
p_samples <- sample(as.matrix(p), 1000)

```

```{r}
n_ind <- nrow(sero)
n_iter <- length(p_samples)

p_ind_samples <- matrix(NA, nrow = n_ind, ncol = n_iter)

for(j in 1:n_iter){

  p_j <- p_samples[j]
  
  p_ind_j <- numeric(n_ind)

  for(i in 1:n_ind){

    t_i = sero$time[i] 
    p_ind_j[i] <- 1 - (1 - p_j)^t_i

  }
  p_ind_samples[,j] <- p_ind_j
}
```

```{r}
p_means = apply(p_ind_samples, 1, mean)
```

```{r}
sd_p <- apply(p_ind_samples, 1, sd)
```

```{r}
Q2.5 <- apply(p_ind_samples, 1, quantile, probs = 0.025)
Q97.5 <- apply(p_ind_samples, 1, quantile, probs = 0.975)
```

```{r}
summary_df <- data.frame(Captor = sero$Cap2, 
                         Obs = sero$infected, 
                         Pred = p_means, 
                         SD = sd_p, 
                         Q2.5 = Q2.5,
                         Q97.5 = Q97.5
                         )

datatable(summary_df)
```

# Model performance check

```{r}
pred <- summary_df$Pred
obs <- summary_df$Obs

# Create a prediction object
prediction <- prediction(pred, obs)

# Create a performance object to calculate ROC and AUC
performance <- performance(prediction, "tpr", "fpr")

# Extract ROC data
roc_data <- data.frame(
  FPR = performance@x.values[[1]],
  TPR = performance@y.values[[1]]
)

# Plot ROC curve using ggplot2
ggplot(roc_data, aes(x = FPR, y = TPR)) +
  geom_line() +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray") +
  labs(title = "ROC Curve", x = "False Positive Rate", y = "True Positive Rate") +
  theme_minimal()
```

```{r}
# Calculate AUC
auc <- performance(prediction, "auc")
cat("AUC:", auc@y.values[[1]])
```
# Some other evaluation metrics and confusion matrix

Since the outcome variable of infection status is binary (infected or not infected), we transformed the estimated probability values into discrete classifications for analysis. Infection probabilities ranging from 0 to 0.5 were designated as class 0 (uninfected) while probabilities from 0.5 to 1 were assigned as class 1 (infected). This divides the probability continuum at the 0.5 threshold to categorize the predictions.

```{r}
threshold <- 0.5
predicted_class <- ifelse(pred >= threshold, 1, 0)

predicted_class <- factor(predicted_class, levels = c(0, 1))
obs <- factor(obs, levels = c(0, 1))

# Create a confusion matrix
confusion_matrix <- confusionMatrix(predicted_class, obs)

plot(confusion_matrix$table, 
     colorRampPalette(colors = c("darkblue","grey","orange"))(100))

# Print the confusion matrix
print(confusion_matrix)
```
