---
title: "Transmission proba estimation : Bayesian model on envelopes data [threshold = 0.3, cutt_off = 2 meters"
output:
  html_document:
    toc: yes
    df_print: paged
  pdf_document:
    toc: yes
    highlight: zenburn
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Importing packages

```{r include=FALSE}
library(nimble)
library(readxl)
library(coda)
library(ggplot2)
library(httpgd)
library(postpack)
library(loo)
library(mcmcplots)
library(Metrics)
library(bayesplot)
library(ROCR)
library(caret)
library(tidyr)
library(dplyr)
```

## Importing data

```{r }
df <- read_excel("D:/Thesis/bernoulli_data_seuil_0.3_cutt_off_2metres.xlsx")
str(df)

y <- df$infected
```

```{r}

df <- df %>%
  pivot_longer(cols = c(time_1, distance_1, time_2, distance_2, time_3, distance_3), 
               names_to = ".value", 
               names_pattern = "([A-Za-z]+)_")


head(df)
```

## Preparing data for Nimble model

```{r }
df$distance <- as.numeric(df$distance)
df$time <- as.integer(df$time)
```

```{r}
t <- df$time
d <- df$distance
env <- replicate(34, 3)
```


```{r}
indexVec1 <- nimbleFunction(
  run = function(x = numeric(), idx = integer()) {
    return(x[idx]) 
  },
  methods = list(),
  setup = function() {}
)

```


## Nimble code

```{r}
ppr_code <- nimbleCode({
  
  # priors
  p0 ~ dbeta(1, 1)
  lambda ~ dlnorm(meanlog = - 1.21812, sdlog = 0.1)
  
  # model
  
  probinsuc <- c()
  
  for(j in 1:length(t)){
    l <- as.integer(j)
    pl <- (1 - p0 * exp(-lambda * d[l]))^t[l]
    probinsuc <- c(probinsuc, pl)
  }
  
  probind <- c()
  
  counter <- 1
  
  for(e in env){
    fine <- counter + e - 1
    probinsucind <- probinsuc[counter:fine]
    pind <- 1 - prod(probinsucind)
    probind <- c(probind, pind)
    counter <- counter + e
  }
  
  # likelihood
  
  for(i in 1:length(y)){
    
    y[i] ~ dbern(probind[i])
    
  }
})
```


## Setting initial values and data

```{r pressure, echo=FALSE}
theta_inits = lapply(1:10, function(i) {
  list(p0 = runif(1,0.001,0.015), lambda = runif(1,0.001,0.0015))
})

data = list(y = y, d=d, t=t, env = env)

```


## Fitting the model to data

```{r}
ppr_mcmc <- nimbleMCMC(code = ppr_code, 
                       inits = theta_inits,
                       data = data,
                       nburnin = 1000, 
                       monitors = c("p0", "lambda"),
                       niter = 50000,
                       nchains = 10,
                       thin = 10,
                       setSeed = 123,
                       progressBar = TRUE,
                       summary = TRUE,
                       WAIC = TRUE)
```



## extracting MCMC samples for each parameters

```{r}
codaSamples <- post_convert(ppr_mcmc$samples)
p0 <- codaSamples[, "p0"]
lambda <- codaSamples[, "lambda"]
```

## Summary of parameter estimations

```{r}
summary(p0)
```

```{r}
summary(lambda)
```

```{r}
densplot(lambda)
```

```{r}
traceplot(lambda)
```

```{r}
densplot(p0)
```

```{r}
traceplot(p0)
```

## Assessing Model quality using WAIC

```{r}
waic <- ppr_mcmc$WAIC
waic
```

## Convergence Checks

```{r}
gelman.diag(lambda)
```

```{r}
geweke.diag(lambda)
```

```{r}
gelman.plot(p0)
```

```{r}
geweke.plot(p0)
```

```{r}
gelman.plot(lambda)
```

```{r}
geweke.plot(lambda)
```

## Predictive checks

### 1. Predictions using estimated parameters

```{r}
lambda_mean <- mean(as.matrix(lambda))
cat("The mean of lambda:", lambda_mean)
```

```{r}
p0_mean <- mean(as.matrix(p0))
cat("The mean of P0:", p0_mean)
```

### 2. Predictions using MCMC parameter samples and Credible intervals

```{r}
p0_samples <- as.matrix(p0)
lambda_samples <- as.matrix(lambda)
```

```{r}
p_samples <- matrix(NA, ncol = length(p0_samples), nrow = length(y))

```

```{r message=FALSE, paged.print=TRUE}

for( i in 1:length(y)){
  
  p[i] <- 1
  datai <- subset(df, collar_tag == i, experiment == experiment) # on extrait les lignes du dataframe envelloppe concernant l'animal i dans l'exp Exp
  
  time <- datai$time
  dist <- datai$distance
  
  for( l in 1:length(time)){
    ptemp <- (1 - p0 * exp(-lambda * dist[l])) ^ time[l]
    p[i] <- p[i] * ptemp
  } 
  p[i] <- 1 - p[i]
}

```

```{r}
mean_p <- apply(p_samples, 1, mean)
```

```{r}
sd_p <- apply(p_samples, 1, sd)

```

```{r}
quantiles <- apply(p_samples, 1, quantile, probs = c(0.025, 0.975))
df$TranProba <- mean_p
df$CI_95 <- t(quantiles)
```

## Evaluation du modÃ¨le

```{r}
predicted <- df$TranProba
actual <- df$infected
```

```{r}
# Create a prediction object
prediction <- prediction(predicted, actual)

# Create a performance object to calculate ROC and AUC
performance <- performance(prediction, "tpr", "fpr")
```

```{r}
# Plot ROC curve
plot(performance)
```

```{r}
# Calculate AUC
auc <- performance(prediction, "auc")
cat("AUC:", auc@y.values[[1]])
```

```{r}
# Access TPR and FPR values
tpr <- performance@y.values[[1]]
fpr <- performance@x.values[[1]]
```

```{r}
threshold <- 0.5
predicted_class <- ifelse(predicted >= threshold, 1, 0)

predicted_class <- factor(predicted_class, levels = c(0, 1))
actual <- factor(actual, levels = c(0, 1))



# Create a confusion matrix
confusion_matrix <- confusionMatrix(predicted_class, actual)

# Print the confusion matrix
print(confusion_matrix)
```

```{r}

```
